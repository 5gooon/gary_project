
# ===============================================
# 초심자가 OOP의 기본 개념 학습용
# 최소한의 클래스 구조로 작성되었습니다.
# ===============================================

class Calculator:
    """간단한 계산기 클래스 - 초심자를 위한 OOP 예제"""
    
    def __init__(self):
        """생성자 - 객체가 생성될 때 실행되는 메서드"""
        print("계산기가 시작되었습니다!")
    
    def get_numbers(self):
        """숫자 입력받기 - 기존 main.py의 로직을 메서드로 분리"""
        while True:
            # while까지는 알았으나, while True + break 구성을 많이쓰며, 무한루프이다.
            num1 = input("첫번째 숫자를 입력하세요: ").strip()
            num2 = input("두번째 숫자를 입력하세요: ").strip()
            #.strip은 공백을 제거해주는 method (gpt참고함), 예외처리도 써보지않아서 참고함.
            try:
                num1_float = float(num1) #소수도 숫자이므로 float사용.
                num2_float = float(num2) 
                break  # 첫 추석처럼 입력성공받으면 무한루프 종료후 print로 출력
            except ValueError:
                #위에 입력값이 숫자형식이 아니면 형식오류이기때문에 ValueError사용
                print("잘못된 입력입니다. 숫자를 다시 입력해 주세요.")
        
        return num1, num2
    
    def get_operator(self):
        """연산자 입력받기 - 기존 main.py의 로직을 메서드로 분리"""
        while True:
            allowed = {"+", "-", "*", "/"}
            cal = input(" +, -, *, / 중 연산은 입력하세요").strip()
            if cal in allowed :
                break
            
            print("잘못된 입력입니다, 연산부호를 다시 입력해주세요.")
        
        return cal
    
    def show_result(self, num1, num2, cal):
        """결과 출력하기 - 기존 main.py의 출력 로직을 메서드로 분리"""
        print(f"첫번째 숫자 : {num1} , 두번째 숫자 : {num2}") #숫자 두개를 동시에 받아서 f-string으로 출력    
        print(f"입력한 연산은 {cal} 입니다.")


def main():
    """메인 함수 - 프로그램의 시작점"""
    # 1. Calculator 객체 생성 (클래스의 인스턴스 생성)
    calculator = Calculator()
    
    # 2. 숫자 입력받기
    num1, num2 = calculator.get_numbers()
    
    # 3. 연산자 입력받기
    cal = calculator.get_operator()
    
    # 4. 결과 출력하기
    calculator.show_result(num1, num2, cal)


# ===============================================
# 📚 OOP 동작 원리 상세 설명
# ===============================================

# 🔍 1. 클래스(Class)란?
# ===========================================
# 클래스는 객체를 만들기 위한 '설계도' 또는 '틀'입니다.
# 예를 들어, '자동차'라는 클래스가 있다면:
# - 자동차의 공통 속성: 바퀴 4개, 엔진, 문 등
# - 자동차의 공통 기능: 달리기, 멈추기, 경적 울리기 등
# 
# 우리의 Calculator 클래스도 마찬가지입니다:
# - 공통 기능: 숫자 입력받기, 연산자 입력받기, 결과 출력하기
# - 이 기능들을 하나로 묶어서 '계산기'라는 개념을 만든 것입니다

# 🏗️ 2. 객체(Object)란?
# ===========================================
# 객체는 클래스를 사용해서 실제로 만든 '인스턴스'입니다.
# 
# 예시:
# calculator1 = Calculator()  # 첫 번째 계산기 객체 생성
# calculator2 = Calculator()  # 두 번째 계산기 객체 생성
# 
# 각각은 독립적인 계산기입니다. 하나를 사용해도 다른 하나에는 영향이 없습니다.
# 마치 같은 설계도로 만든 두 대의 자동차가 서로 다른 것과 같습니다.

# ⚙️ 3. 메서드(Method)란?
# ===========================================
# 메서드는 클래스 안에 정의된 함수입니다.
# 일반 함수와의 차이점:
# - 메서드는 클래스에 속해있음
# - self 매개변수를 첫 번째로 받음 (현재 객체를 가리킴)
# 
# 예시:
# def get_numbers(self):  # self는 현재 Calculator 객체를 의미
#     # 이 메서드는 Calculator 클래스에 속해있음
#     pass
# 
# 일반 함수:
# def normal_function():  # self 없음
#     # 독립적인 함수
#     pass

# 🚀 4. 생성자(__init__)란?
# ===========================================
# 생성자는 객체가 생성될 때 자동으로 실행되는 특별한 메서드입니다.
# 
# 동작 과정:
# 1. calculator = Calculator() 실행
# 2. Python이 Calculator 클래스의 __init__ 메서드를 자동 호출
# 3. __init__ 메서드 안의 코드가 실행됨
# 4. 객체 생성 완료
# 
# 예시:
# def __init__(self):
#     print("계산기가 시작되었습니다!")  # 객체 생성 시 자동 실행
# 
# 이 코드는 객체가 생성될 때마다 실행됩니다.

# 📦 5. 캡슐화(Encapsulation)란?
# ===========================================
# 캡슐화는 관련된 데이터와 기능을 하나의 클래스로 묶어서 관리하는 것입니다.
# 
# 장점:
# - 코드의 구조가 명확해짐
# - 관련 기능을 쉽게 찾을 수 있음
# - 코드 재사용이 쉬워짐
# 
# 우리 코드에서의 캡슐화:
# - 숫자 입력 관련: get_numbers() 메서드
# - 연산자 입력 관련: get_operator() 메서드  
# - 결과 출력 관련: show_result() 메서드
# - 모든 기능이 Calculator 클래스 안에 정리되어 있음

# 🔄 6. 실제 동작 과정 상세 분석
# ===========================================
# 
# 1단계: 객체 생성
# calculator = Calculator()
# ↓
# Python이 Calculator 클래스의 __init__ 메서드 호출
# ↓
# "계산기가 시작되었습니다!" 출력
# ↓
# calculator 객체 생성 완료
# 
# 2단계: 숫자 입력
# num1, num2 = calculator.get_numbers()
# ↓
# Calculator 클래스의 get_numbers() 메서드 실행
# ↓
# 사용자로부터 숫자 입력받고 검증
# ↓
# 검증된 숫자들을 반환
# 
# 3단계: 연산자 입력
# cal = calculator.get_operator()
# ↓
# Calculator 클래스의 get_operator() 메서드 실행
# ↓
# 사용자로부터 연산자 입력받고 검증
# ↓
# 검증된 연산자 반환
# 
# 4단계: 결과 출력
# calculator.show_result(num1, num2, cal)
# ↓
# Calculator 클래스의 show_result() 메서드 실행
# ↓
# 입력받은 값들을 출력

# 💡 7. 왜 OOP를 사용할까?
# ===========================================
# 
# 장점:
# 1. 코드 재사용: 같은 클래스로 여러 객체 생성 가능
# 2. 유지보수 용이: 관련 기능이 한 곳에 모여있음
# 3. 확장성: 새로운 기능 추가가 쉬움
# 4. 가독성: 코드 구조가 명확함
# 
# 예시:
# calculator1 = Calculator()  # 첫 번째 계산기
# calculator2 = Calculator()  # 두 번째 계산기
# calculator3 = Calculator()  # 세 번째 계산기
# 
# 각각 독립적으로 사용 가능!

# 🎯 8. 핵심 개념 정리
# ===========================================
# - 클래스: 설계도 (Calculator)
# - 객체: 실제 제품 (calculator)
# - 메서드: 기능 (get_numbers, get_operator, show_result)
# - 생성자: 초기 설정 (__init__)
# - 캡슐화: 관련 기능을 하나로 묶기
# ===============================================

if __name__ == "__main__":
    main()